{"version":3,"file":"index.mjs","sources":["../src/src/core/utils.ts","../src/src/core/cache.ts","../src/src/core/store.ts","../src/src/react/useIsomorphicLayoutEffect.ts","../src/src/react/useSyncExternalStore.ts","../src/src/core/dom.ts","../src/src/core/scroller.ts","../src/src/react/utils.ts","../src/src/react/useStatic.ts","../src/src/react/useRefWithUpdate.ts","../src/src/react/VList.tsx","../src/src/core/resizer.ts","../src/src/react/VGrid.tsx"],"sourcesContent":["export const min = Math.min;\nexport const max = Math.max;\nexport const now = Date.now;\n\nexport const exists = <T>(v: T): v is Exclude<T, null | undefined> => v != null;\n\nexport const range = <T>(length: number, cb: (i: number) => T): T[] =>\n  Array.from({ length }, (_, i) => cb(i));\n\nexport const debounce = <T extends (...args: any[]) => void>(\n  fn: T,\n  ms: number\n) => {\n  let id: NodeJS.Timeout | undefined | null;\n\n  const cancel = () => {\n    if (exists(id)) {\n      clearTimeout(id);\n    }\n  };\n  const debouncedFn = () => {\n    cancel();\n    id = setTimeout(() => {\n      id = null;\n      fn();\n    }, ms);\n  };\n  debouncedFn._cancel = cancel;\n  return debouncedFn;\n};\n\nexport const throttle = <T extends (...args: any[]) => void>(\n  fn: T,\n  ms: number\n) => {\n  let time = now() - ms;\n  return (...args: Parameters<T>) => {\n    const n = now();\n    if (time + ms < n) {\n      time = n;\n      fn(...args);\n    }\n  };\n};\n\nexport const once = <F extends (...args: any[]) => any>(fn: F): F => {\n  let called: undefined | boolean;\n  let cache: ReturnType<F>;\n\n  return ((...args) => {\n    if (!called) {\n      called = true;\n      cache = fn(...args);\n    }\n    return cache;\n  }) as F;\n};\n","import type { DeepReadonly, Writeable } from \"./types\";\nimport { exists, max, min, range } from \"./utils\";\n\nexport const UNCACHED = -1;\n\nexport type Cache = DeepReadonly<{\n  _defaultItemSize: number;\n  _length: number;\n  _sizes: number[];\n  _measuredOffsetIndex: number;\n  _offsets: number[];\n}>;\n\nexport const getItemSize = (cache: Cache, index: number): number => {\n  const size = cache._sizes[index]!;\n  return size === UNCACHED ? cache._defaultItemSize : size;\n};\n\nexport const setItemSize = (\n  cache: Writeable<Cache>,\n  index: number,\n  size: number\n) => {\n  cache._sizes[index] = size;\n  // mark as dirty\n  cache._measuredOffsetIndex = min(index, cache._measuredOffsetIndex);\n};\n\nconst computeOffset = (\n  cache: Writeable<Cache>,\n  index: number,\n  isTotal?: boolean\n): number => {\n  if (!cache._length) return 0;\n  if (cache._measuredOffsetIndex >= index) {\n    if (isTotal) {\n      return cache._offsets[index]! + getItemSize(cache, index);\n    } else {\n      return cache._offsets[index]!;\n    }\n  }\n\n  let i = cache._measuredOffsetIndex;\n  let top = cache._offsets[i]!;\n  while (i <= index) {\n    cache._offsets[i] = top;\n    if (i === index && !isTotal) {\n      break;\n    }\n    top += getItemSize(cache, i);\n    i++;\n  }\n  // mark as measured\n  cache._measuredOffsetIndex = index;\n  return top;\n};\n\nexport const computeTotalSize = (cache: Writeable<Cache>): number => {\n  return computeOffset(cache, cache._length - 1, true);\n};\n\nexport const computeStartOffset = (\n  cache: Writeable<Cache>,\n  index: number\n): number => {\n  return computeOffset(cache, index);\n};\n\nconst findIndex = (cache: Cache, i: number, distance: number): number => {\n  let sum = 0;\n  if (distance >= 0) {\n    // search forward\n    while (i < cache._length - 1) {\n      const h = getItemSize(cache, i++);\n      if ((sum += h) >= distance) {\n        if (sum - h / 2 >= distance) {\n          i--;\n        }\n        break;\n      }\n    }\n  } else {\n    // search backward\n    while (i > 0) {\n      const h = getItemSize(cache, --i);\n      if ((sum -= h) <= distance) {\n        if (sum + h / 2 < distance) {\n          i++;\n        }\n        break;\n      }\n    }\n  }\n\n  return min(max(i, 0), cache._length - 1);\n};\n\nexport const findStartIndexWithOffset = (\n  cache: Cache,\n  offset: number,\n  prevStartIndex: number,\n  prevOffset: number\n): number => {\n  return findIndex(cache, prevStartIndex, offset - prevOffset);\n};\n\nexport const findEndIndex = findIndex;\n\nexport const hasUnmeasuredItemsInRange = (\n  cache: Cache,\n  startIndex: number,\n  endIndex: number\n): boolean => {\n  for (let i = startIndex; i <= endIndex; i++) {\n    if (cache._sizes[i] === UNCACHED) {\n      return true;\n    }\n  }\n  return false;\n};\n\nexport const resetCache = (\n  length: number,\n  itemSize: number,\n  cache?: Cache\n): Cache => {\n  return {\n    _defaultItemSize: itemSize,\n    _length: length,\n    _measuredOffsetIndex: cache\n      ? min(cache._measuredOffsetIndex, length - 1)\n      : 0,\n    _sizes: range(length, (i) => {\n      const size = cache && cache._sizes[i];\n      if (exists(size)) {\n        return size;\n      }\n      return UNCACHED;\n    }),\n    _offsets: range(length, (i) => {\n      if (i === 0) {\n        // first offset must be 0\n        return 0;\n      }\n      const offset = cache && cache._offsets[i];\n      if (exists(offset)) {\n        return offset;\n      }\n      return UNCACHED;\n    }),\n  };\n};\n","import {\n  findStartIndexWithOffset,\n  resetCache,\n  getItemSize,\n  computeTotalSize,\n  findEndIndex,\n  computeStartOffset,\n  Cache,\n  UNCACHED,\n  setItemSize,\n  hasUnmeasuredItemsInRange,\n} from \"./cache\";\nimport type { Writeable } from \"./types\";\nimport { max } from \"./utils\";\n\ntype ItemJump = [sizeDiff: number, index: number];\nexport type ScrollJump = Readonly<ItemJump[]>;\nexport type ItemResize = [index: number, size: number];\ntype ItemsRange = [startIndex: number, endIndex: number];\n\nexport const SCROLL_STOP = 0;\nexport const SCROLL_DOWN = 1;\nexport const SCROLL_UP = 2;\nexport const SCROLL_MANUAL = 3;\ntype ScrollDirection =\n  | typeof SCROLL_STOP\n  | typeof SCROLL_DOWN\n  | typeof SCROLL_UP\n  | typeof SCROLL_MANUAL;\n\nexport const ACTION_ITEM_RESIZE = 1;\nexport const ACTION_WINDOW_RESIZE = 2;\nexport const ACTION_SCROLL = 3;\nexport const ACTION_MANUAL_SCROLL = 4;\n\ntype Actions =\n  | [type: typeof ACTION_ITEM_RESIZE, entries: ItemResize[]]\n  | [type: typeof ACTION_WINDOW_RESIZE, size: number]\n  | [type: typeof ACTION_SCROLL, offset: number]\n  | [type: typeof ACTION_MANUAL_SCROLL, offset: number];\n\nexport type VirtualStore = {\n  _getRange(): ItemsRange;\n  _isUnmeasuredItem(index: number): boolean;\n  _hasUnmeasuredItemsInRange(startIndex: number): boolean;\n  _getItemOffset(index: number): number;\n  _getItemSize(index: number): number;\n  _getScrollOffset(): number;\n  _getViewportSize(): number;\n  _getScrollSize(): number;\n  _getJump(): ScrollJump;\n  _isHorizontal(): boolean;\n  _isRtl(): boolean;\n  _getItemIndexForScrollTo(offset: number): number;\n  _waitForScrollDestinationItemsMeasured(): Promise<void>;\n  _subscribe(cb: () => void): () => void;\n  _update(...action: Actions): void;\n  _getScrollDirection(): ScrollDirection;\n  _setScrollDirection(direction: ScrollDirection): void;\n  _updateCacheLength(length: number): void;\n};\n\nexport const createVirtualStore = (\n  itemCount: number,\n  itemSize: number,\n  isHorizontal: boolean,\n  isRtl: boolean,\n  initialItemCount: number = 0,\n  onScrollStateChange: (scrolling: boolean) => void,\n  onScrollOffsetChange: (offset: number) => void\n): VirtualStore => {\n  let viewportSize = itemSize * max(initialItemCount - 1, 0);\n  let scrollOffset = 0;\n  let jump: ItemJump[] = [];\n  let cache = resetCache(itemCount, itemSize);\n  let scrollDirection: ScrollDirection = SCROLL_STOP;\n  let _prevRange: ItemsRange = [0, initialItemCount];\n  let _scrollToQueue: [() => void, () => void] | undefined;\n\n  const subscribers = new Set<() => void>();\n\n  return {\n    _getRange() {\n      const [prevStartIndex, prevEndIndex] = _prevRange;\n      const prevOffset = computeStartOffset(\n        cache as Writeable<Cache>,\n        prevStartIndex\n      );\n      const start = findStartIndexWithOffset(\n        cache,\n        scrollOffset,\n        prevStartIndex,\n        prevOffset\n      );\n      const end = findEndIndex(cache, start, viewportSize);\n      if (prevStartIndex === start && prevEndIndex === end) {\n        return _prevRange;\n      }\n      return (_prevRange = [start, end]);\n    },\n    _isUnmeasuredItem(index) {\n      return cache._sizes[index] === UNCACHED;\n    },\n    _hasUnmeasuredItemsInRange(startIndex) {\n      return hasUnmeasuredItemsInRange(\n        cache,\n        startIndex,\n        findEndIndex(cache, startIndex, viewportSize)\n      );\n    },\n    _getItemOffset(index) {\n      return computeStartOffset(cache as Writeable<Cache>, index);\n    },\n    _getItemSize(index) {\n      return getItemSize(cache, index);\n    },\n    _getScrollOffset() {\n      return scrollOffset;\n    },\n    _getViewportSize() {\n      return viewportSize;\n    },\n    _getScrollSize() {\n      return computeTotalSize(cache as Writeable<Cache>);\n    },\n    _getJump() {\n      return jump;\n    },\n    _isHorizontal() {\n      return isHorizontal;\n    },\n    _isRtl() {\n      return isRtl;\n    },\n    _getItemIndexForScrollTo(offset) {\n      return findStartIndexWithOffset(cache, offset, 0, 0);\n    },\n    _waitForScrollDestinationItemsMeasured() {\n      if (_scrollToQueue) {\n        // Cancel waiting scrollTo\n        _scrollToQueue[1]();\n      }\n      // The measurement will be done asynchronously and the timing is not predictable so we use promise.\n      // For example, ResizeObserver may not fire when window is not visible.\n      return new Promise((resolve, reject) => {\n        _scrollToQueue = [\n          () => {\n            // HACK: It should be resolved in the next microtask that is after React's render\n            Promise.resolve().then(() => {\n              resolve();\n              _scrollToQueue = undefined;\n            });\n          },\n          reject,\n        ];\n      });\n    },\n    _subscribe(cb) {\n      subscribers.add(cb);\n      return () => {\n        subscribers.delete(cb);\n      };\n    },\n    _update(type, payload) {\n      const mutated = ((): boolean => {\n        switch (type) {\n          case ACTION_ITEM_RESIZE: {\n            const updated = payload.filter(\n              ([index, size]) => cache._sizes[index] !== size\n            );\n            // Skip if all items are cached and not updated\n            if (!updated.length) {\n              return false;\n            }\n\n            const updatedJump: ItemJump[] = [];\n            updated.forEach(([index, size]) => {\n              updatedJump.push([size - getItemSize(cache, index), index]);\n              setItemSize(cache as Writeable<Cache>, index, size);\n            });\n            jump = updatedJump;\n            return true;\n          }\n          case ACTION_WINDOW_RESIZE: {\n            if (viewportSize === payload) {\n              return false;\n            }\n            viewportSize = payload;\n            return true;\n          }\n          case ACTION_SCROLL:\n          case ACTION_MANUAL_SCROLL: {\n            const prevOffset = scrollOffset;\n            return (scrollOffset = payload) !== prevOffset;\n          }\n        }\n      })();\n\n      if (mutated) {\n        subscribers.forEach((cb) => {\n          cb();\n        });\n\n        if (type === ACTION_SCROLL) {\n          onScrollOffsetChange(scrollOffset);\n        } else if (_scrollToQueue && type === ACTION_ITEM_RESIZE) {\n          _scrollToQueue[0]();\n        }\n      }\n    },\n    _getScrollDirection() {\n      return scrollDirection;\n    },\n    _setScrollDirection(dir) {\n      const prev = scrollDirection;\n      scrollDirection = dir;\n      if (scrollDirection === SCROLL_STOP) {\n        onScrollStateChange(false);\n      } else if (\n        prev === SCROLL_STOP &&\n        (scrollDirection === SCROLL_DOWN || scrollDirection === SCROLL_UP)\n      ) {\n        onScrollStateChange(true);\n      }\n    },\n    _updateCacheLength(length) {\n      // It's ok to be updated in render because states should be calculated consistently regardless cache length\n      if (cache._length === length) return;\n      cache = resetCache(length, itemSize, cache);\n    },\n  };\n};\n","import { useEffect, useLayoutEffect } from \"react\";\n\n// https://gist.github.com/gaearon/e7d97cdf38a2907924ea12e4ebdf3c85\nexport const useIsomorphicLayoutEffect =\n  typeof window !== \"undefined\" ? useLayoutEffect : useEffect;\n","import { useSyncExternalStore as _useSyncExternalStore } from \"use-sync-external-store/shim/index.js\";\n\nexport const useSyncExternalStore = <T>(\n  subscibe: (onStoreChange: () => void) => () => void,\n  getSnapShot: () => T\n): T => {\n  return _useSyncExternalStore(subscibe, getSnapShot, getSnapShot);\n};\n","import { once } from \"./utils\";\n\n// The scroll position may be negative value in rtl direction.\n//\n// left  right result\n// -100  0     true    spec compliant\n// 0     100   false   probably Chrome earlier than v85\n// https://github.com/othree/jquery.rtl-scroll-type\nexport const hasNegativeOffsetInRtl = once((scrollable: HTMLElement) => {\n  const key = \"scrollLeft\";\n  const prev = scrollable[key];\n  scrollable[key] = 1;\n  // scrollLeft can be positive under some specific situations even if negative mode, so we use `<` for now.\n  const isNegative = scrollable[key] < 1;\n  scrollable[key] = prev;\n  return isNegative;\n});\n","import { hasNegativeOffsetInRtl } from \"./dom\";\nimport {\n  ACTION_SCROLL,\n  ACTION_MANUAL_SCROLL,\n  ScrollJump,\n  VirtualStore,\n  SCROLL_MANUAL,\n  SCROLL_STOP,\n  SCROLL_UP,\n  SCROLL_DOWN,\n} from \"./store\";\nimport { debounce, throttle, max, min } from \"./utils\";\n\nexport type Scroller = {\n  _initRoot: (rootElement: HTMLElement) => () => void;\n  _getActualScrollSize: () => number;\n  _scrollTo: (offset: number) => void;\n  _scrollToIndex: (index: number, count: number) => void;\n  _fixScrollJump: (jump: ScrollJump, startIndex: number) => void;\n};\n\nexport const createScroller = (\n  store: VirtualStore,\n  isJustResized: () => boolean\n): Scroller => {\n  let rootElement: HTMLElement | undefined;\n  const isHorizontal = store._isHorizontal();\n  const isRtl = store._isRtl();\n  const scrollToKey = isHorizontal ? \"scrollLeft\" : \"scrollTop\";\n\n  const getActualScrollSize = (): number => {\n    if (!rootElement) return 0;\n    // Use element's scrollHeight/scrollWidth instead of stored scrollSize.\n    // This is because stored size may differ from the actual size, for example when a new item is added and not yet measured.\n    return isHorizontal ? rootElement.scrollWidth : rootElement.scrollHeight;\n  };\n  const normalizeRtlOffset = (offset: number, diff?: boolean): number => {\n    if (hasNegativeOffsetInRtl(rootElement!)) {\n      return -offset;\n    } else {\n      return diff\n        ? -offset\n        : store._getScrollSize() - store._getViewportSize() - offset;\n    }\n  };\n  const scrollTo = (offset: number, diff?: boolean) => {\n    if (!rootElement) return;\n    if (isHorizontal && isRtl) {\n      offset = normalizeRtlOffset(offset, diff);\n    }\n    if (diff) {\n      rootElement[scrollToKey] += offset;\n    } else {\n      rootElement[scrollToKey] = offset;\n      store._setScrollDirection(SCROLL_MANUAL);\n    }\n  };\n  const scrollManually = async (\n    index: number,\n    getCurrentOffset: () => number\n  ) => {\n    const getOffset = (): number => {\n      let offset = getCurrentOffset();\n      const scrollSize = getActualScrollSize();\n      const viewportSize = store._getViewportSize();\n      if (scrollSize - (offset + viewportSize) <= 0) {\n        // Adjust if the offset is over the end, to get correct startIndex.\n        offset = scrollSize - viewportSize;\n      }\n      return offset;\n    };\n\n    if (store._hasUnmeasuredItemsInRange(index)) {\n      do {\n        // In order to scroll to the correct position, mount the items and measure their sizes before scrolling.\n        store._update(ACTION_MANUAL_SCROLL, getOffset());\n        try {\n          // Wait for the scroll destination items to be measured.\n          await store._waitForScrollDestinationItemsMeasured();\n        } catch (e) {\n          // canceled\n          return;\n        }\n      } while (store._hasUnmeasuredItemsInRange(index));\n\n      // Scroll with the updated value\n      scrollTo(getOffset());\n    } else {\n      const offset = getOffset();\n      scrollTo(offset);\n      // Sync viewport to scroll destination\n      store._update(ACTION_MANUAL_SCROLL, offset);\n    }\n  };\n\n  const calcTotalJump = (jump: ScrollJump): number =>\n    jump.reduce((acc, [j]) => acc + j, 0);\n\n  return {\n    _initRoot(root) {\n      rootElement = root;\n\n      const syncViewportToScrollPosition = () => {\n        let offset = root[scrollToKey];\n        if (isHorizontal && isRtl) {\n          offset = normalizeRtlOffset(offset);\n        }\n        const prevOffset = store._getScrollOffset();\n        if (prevOffset === offset) {\n          return;\n        }\n        const scrollDirection = store._getScrollDirection();\n        // Skip scroll direction detection just after resizing because it may result in the opposite direction.\n        // Scroll events are dispatched enough so it's ok to skip some of them.\n        const resized = isJustResized();\n        if (\n          (scrollDirection === SCROLL_STOP || !resized) &&\n          // Ignore until manual scrolling\n          scrollDirection !== SCROLL_MANUAL\n        ) {\n          store._setScrollDirection(\n            prevOffset > offset ? SCROLL_UP : SCROLL_DOWN\n          );\n        }\n        store._update(ACTION_SCROLL, offset);\n      };\n\n      const onScrollStopped = debounce(() => {\n        // Check scroll position once just after scrolling stopped\n        syncViewportToScrollPosition();\n        store._setScrollDirection(SCROLL_STOP);\n      }, 150);\n\n      const onScroll = () => {\n        syncViewportToScrollPosition();\n        onScrollStopped();\n      };\n\n      // Infer scroll state also from wheel events\n      // Sometimes scroll events do not fire when frame dropped even if the visual have been already scrolled\n      const onWheel = throttle((e: WheelEvent) => {\n        if (store._getScrollDirection() === SCROLL_STOP) {\n          // Scroll start should be detected with scroll event\n          return;\n        }\n        if (e.ctrlKey) {\n          // Probably a pinch-to-zoom gesture\n          return;\n        }\n        // Get delta before checking deltaMode for firefox behavior\n        // https://github.com/w3c/uievents/issues/181#issuecomment-392648065\n        // https://bugzilla.mozilla.org/show_bug.cgi?id=1392460#c34\n        if (isHorizontal ? e.deltaX : e.deltaY) {\n          const offset = store._getScrollOffset();\n          if (\n            offset > 0 &&\n            offset < store._getScrollSize() - store._getViewportSize()\n          ) {\n            onScrollStopped();\n          }\n        }\n      }, 50);\n\n      root.addEventListener(\"scroll\", onScroll);\n      root.addEventListener(\"wheel\", onWheel, { passive: true });\n\n      return () => {\n        root.removeEventListener(\"scroll\", onScroll);\n        root.removeEventListener(\"wheel\", onWheel);\n        onScrollStopped._cancel();\n      };\n    },\n    _getActualScrollSize: getActualScrollSize,\n    _scrollTo(offset) {\n      offset = max(offset, 0);\n\n      scrollManually(store._getItemIndexForScrollTo(offset), () => offset);\n    },\n    _scrollToIndex(index, count) {\n      index = max(min(index, count - 1), 0);\n\n      scrollManually(index, () => store._getItemOffset(index));\n    },\n    _fixScrollJump: (jump, startIndex) => {\n      const scrollDirection = store._getScrollDirection();\n      // Compensate scroll jump\n      if (scrollDirection === SCROLL_UP) {\n        const diff = calcTotalJump(jump);\n        if (diff) {\n          scrollTo(diff, true);\n        }\n      } else if (scrollDirection === SCROLL_MANUAL) {\n        const offset = store._getScrollOffset();\n        if (offset === 0) {\n          // Do nothing to stick to the start\n        } else {\n          const allDiff = calcTotalJump(jump);\n          if (\n            store._getScrollSize() -\n              (offset + store._getViewportSize() + allDiff) <=\n            0\n          ) {\n            // Keep end to stick to the end\n            if (allDiff) {\n              scrollTo(offset + allDiff);\n            }\n          } else {\n            // Keep start at mid\n            const diff = jump.reduce((acc, [j, index]) => {\n              if (index < startIndex) {\n                acc += j;\n              }\n              return acc;\n            }, 0);\n            if (diff) {\n              scrollTo(diff, true);\n            }\n          }\n        }\n      } else {\n        // NOP\n      }\n    },\n  };\n};\n","import { ReactNode } from \"react\";\nimport { exists } from \"../core/utils\";\n\nexport const refKey = \"current\";\n\nexport const isInvalidElement = <T extends ReactNode>(\n  e: T\n): e is Extract<T, null | undefined | boolean> =>\n  !exists(e) || typeof e === \"boolean\";\n","import { useRef } from \"react\";\nimport { refKey } from \"./utils\";\n\nexport const useStatic = <T>(init: () => T): T => {\n  const ref = useRef<T>();\n  return ref[refKey] || (ref[refKey] = init());\n};\n","import { useRef } from \"react\";\nimport { useIsomorphicLayoutEffect } from \"./useIsomorphicLayoutEffect\";\nimport { refKey } from \"./utils\";\n\nexport const useRefWithUpdate = <T>(value: T) => {\n  const ref = useRef<T>(value);\n\n  useIsomorphicLayoutEffect(() => {\n    ref[refKey] = value;\n  }, [value]);\n\n  return ref;\n};\n","import {\n  Children,\n  memo,\n  useRef,\n  useMemo,\n  CSSProperties,\n  ReactElement,\n  forwardRef,\n  useImperativeHandle,\n  ReactNode,\n  useEffect,\n  RefObject,\n  useState,\n  ReactFragment,\n} from \"react\";\nimport { VirtualStore, createVirtualStore } from \"../core/store\";\nimport { useIsomorphicLayoutEffect } from \"./useIsomorphicLayoutEffect\";\nimport { useSyncExternalStore } from \"./useSyncExternalStore\";\nimport { exists, max, min } from \"../core/utils\";\nimport { createScroller } from \"../core/scroller\";\nimport { isInvalidElement, refKey } from \"./utils\";\nimport { useStatic } from \"./useStatic\";\nimport { useRefWithUpdate } from \"./useRefWithUpdate\";\nimport { Resizer, createResizer } from \"../core/resizer\";\nimport { WindowComponentAttributes } from \"..\";\n\ntype ItemProps = {\n  _children: ReactNode;\n  _resizer: Resizer;\n  _store: VirtualStore;\n  _index: number;\n  _element: \"div\";\n};\n\nconst Item = memo(\n  ({\n    _children: children,\n    _resizer: resizer,\n    _store: store,\n    _index: index,\n    _element: Element,\n  }: ItemProps): ReactElement => {\n    const ref = useRef<HTMLDivElement>(null);\n\n    const offset = useSyncExternalStore(store._subscribe, () =>\n      store._getItemOffset(index)\n    );\n    const hide = useSyncExternalStore(store._subscribe, () =>\n      store._isUnmeasuredItem(index)\n    );\n\n    // The index may be changed if elements are inserted to or removed from the start of props.children\n    useIsomorphicLayoutEffect(\n      () => resizer._observeItem(ref[refKey]!, index),\n      [index]\n    );\n\n    return (\n      <Element\n        ref={ref}\n        style={useMemo((): CSSProperties => {\n          const isHorizontal = store._isHorizontal();\n          const leftOrRightKey = store._isRtl() ? \"right\" : \"left\";\n          const style: CSSProperties = {\n            margin: 0,\n            padding: 0,\n            position: \"absolute\",\n            [isHorizontal ? \"height\" : \"width\"]: \"100%\",\n            [isHorizontal ? \"top\" : leftOrRightKey]: 0,\n            [isHorizontal ? leftOrRightKey : \"top\"]: offset,\n            visibility: hide ? \"hidden\" : \"visible\",\n            // willChange: \"transform\",\n          };\n          if (isHorizontal) {\n            style.display = \"flex\";\n          }\n          return style;\n        }, [offset, hide])}\n      >\n        {children}\n      </Element>\n    );\n  }\n);\n\n/**\n * Props of customized scrollable component for {@link VList}.\n */\nexport interface CustomWindowComponentProps {\n  children: ReactNode;\n  scrollSize: number;\n  scrolling: boolean;\n  horizontal: boolean;\n  attrs: WindowComponentAttributes;\n}\n\nconst DefaultWindow = forwardRef<any, CustomWindowComponentProps>(\n  (\n    { children, scrollSize, scrolling, horizontal, attrs },\n    ref\n  ): ReactElement => {\n    return (\n      <div ref={ref} {...attrs}>\n        <div\n          style={useMemo((): CSSProperties => {\n            return {\n              position: \"relative\",\n              visibility: \"hidden\",\n              width: horizontal ? scrollSize : \"100%\",\n              height: horizontal ? \"100%\" : scrollSize,\n              pointerEvents: scrolling ? \"none\" : \"auto\",\n            };\n          }, [scrollSize, scrolling])}\n        >\n          {children}\n        </div>\n      </div>\n    );\n  }\n);\n\nexport type CustomWindowComponent = typeof DefaultWindow;\n\nconst Window = ({\n  _children: children,\n  _ref: ref,\n  _store: store,\n  _element: Element,\n  _scrolling: scrolling,\n  _attrs: attrs,\n}: {\n  _children: ReactNode;\n  _ref: RefObject<HTMLDivElement>;\n  _store: VirtualStore;\n  _element: CustomWindowComponent;\n  _scrolling: boolean;\n  _attrs: WindowComponentAttributes;\n}) => {\n  const scrollSize = useSyncExternalStore(\n    store._subscribe,\n    store._getScrollSize\n  );\n\n  const horizontal = store._isHorizontal();\n\n  return (\n    <Element\n      ref={ref}\n      scrollSize={scrollSize}\n      scrolling={scrolling}\n      horizontal={horizontal}\n      attrs={useMemo(\n        () => ({\n          ...attrs,\n          style: {\n            overflow: horizontal ? \"auto hidden\" : \"hidden auto\",\n            contain: \"strict\",\n            // transform: \"translate3d(0px, 0px, 0px)\",\n            // willChange: \"scroll-position\",\n            // backfaceVisibility: \"hidden\",\n            width: \"100%\",\n            height: \"100%\",\n            padding: 0,\n            margin: 0,\n            ...attrs.style,\n          },\n        }),\n        [attrs]\n      )}\n    >\n      {children}\n    </Element>\n  );\n};\n\n/**\n * Props of customized item component for {@link VList}.\n */\nexport interface CustomItemComponentProps {\n  style: CSSProperties;\n  children: ReactNode;\n}\n\nexport type CustomItemComponent = React.ForwardRefExoticComponent<\n  React.PropsWithoutRef<CustomItemComponentProps> & React.RefAttributes<any>\n>;\n\ntype CustomItemComponentOrElement =\n  | keyof JSX.IntrinsicElements\n  | CustomItemComponent;\n\n/**\n * Methods of {@link VList}.\n */\nexport interface VListHandle {\n  /**\n   * Get current scrollTop or scrollLeft.\n   */\n  readonly scrollOffset: number;\n  /**\n   * Get current scrollHeight or scrollWidth.\n   */\n  readonly scrollSize: number;\n  /**\n   * Get current offsetHeight or offsetWidth.\n   */\n  readonly viewportSize: number;\n  /**\n   * Scroll to the item specified by index.\n   * @param index index of item\n   */\n  scrollToIndex(index: number): void;\n  /**\n   * Scroll to the given offset.\n   * @param offset offset from start\n   */\n  scrollTo(offset: number): void;\n  /**\n   * Scroll by the given offset.\n   * @param offset offset from current position\n   */\n  scrollBy(offset: number): void;\n}\n\n/**\n * Props of {@link VList}.\n */\nexport interface VListProps extends WindowComponentAttributes {\n  /**\n   * Elements rendered by this component.\n   */\n  children: ReactNode;\n  /**\n   * Item size hint for unmeasured items. It's recommended to specify this prop if item sizes are fixed and known, or much larger than the defaultValue. It will help to reduce scroll jump when items are measured.\n   * @defaultValue 40\n   */\n  itemSize?: number;\n  /**\n   * Number of items to render above/below the visible bounds of the list. You can increase to avoid showing blank items in fast scrolling.\n   * @defaultValue 4\n   */\n  overscan?: number;\n  /**\n   * If set, the specified amount of items will be mounted in the initial rendering regardless of the container size. This prop is mostly for SSR.\n   */\n  initialItemCount?: number;\n  /**\n   * If true, rendered as a horizontally scrollable list. Otherwise rendered as a vertically scrollable list.\n   */\n  horizontal?: boolean;\n  /**\n   * You have to set true if you use this component under `direction: rtl` style.\n   */\n  rtl?: boolean;\n  /**\n   * Customized element type for scrollable element. This element will get {@link CustomWindowComponentProps} as props.\n   * @defaultValue {@link DefaultWindow}\n   */\n  element?: CustomWindowComponent;\n  /**\n   * Customized element type for item element. This element will get {@link CustomItemComponentProps} as props.\n   * @defaultValue \"div\"\n   */\n  itemElement?: CustomItemComponentOrElement;\n  /**\n   * Callback invoked whenever scroll offset changes.\n   * @param offset Current scrollTop or scrollLeft.\n   */\n  onScroll?: (offset: number) => void;\n  /**\n   * Callback invoked when scrolling stops.\n   */\n  onScrollStop?: () => void;\n  /**\n   * Callback invoked when visible items range changes.\n   */\n  onRangeChange?: (payload: {\n    /**\n     * The start index of viewable items.\n     */\n    start: number;\n    /**\n     * The end index of viewable items.\n     */\n    end: number;\n    /**\n     * The total count of items.\n     */\n    count: number;\n  }) => void;\n}\n\n/**\n * Virtualized list component. See {@link VListProps} and {@link VListHandle}.\n */\nexport const VList = forwardRef<VListHandle, VListProps>(\n  (\n    {\n      children,\n      itemSize: itemSizeProp = 40,\n      overscan = 4,\n      initialItemCount,\n      horizontal: horizontalProp,\n      rtl: rtlProp,\n      element = DefaultWindow,\n      itemElement = \"div\",\n      onScroll: onScrollProp,\n      onScrollStop: onScrollStopProp,\n      onRangeChange: onRangeChangeProp,\n      ...windowAttrs\n    },\n    ref\n  ): ReactElement => {\n    // Memoize element array\n    const elements = useMemo(() => {\n      const arr: (ReactElement | ReactFragment | string | number)[] = [];\n      Children.forEach(children, (e) => {\n        if (isInvalidElement(e)) {\n          return;\n        }\n        arr.push(e);\n      });\n      return arr;\n    }, [children]);\n    const count = elements.length;\n\n    const onScroll = useRefWithUpdate(onScrollProp);\n    const onScrollStop = useRefWithUpdate(onScrollStopProp);\n\n    const [mountedIndexes, reset] = useState<Set<number>>(new Set<number>());\n    const [scrolling, setScrolling] = useState(false);\n    // https://github.com/facebook/react/issues/25191#issuecomment-1237456448\n    const [store, resizer, scroller] = useStatic(() => {\n      const _store = createVirtualStore(\n        count,\n        itemSizeProp,\n        !!horizontalProp,\n        !!rtlProp,\n        initialItemCount,\n        (isScrolling) => {\n          setScrolling(isScrolling);\n          if (!isScrolling) {\n            reset(new Set());\n            onScrollStop[refKey] && onScrollStop[refKey]();\n          }\n        },\n        (offset) => {\n          onScroll[refKey] && onScroll[refKey](offset);\n        }\n      );\n      const _resizer = createResizer(_store);\n      return [\n        _store,\n        _resizer,\n        createScroller(_store, _resizer._isJustResized),\n      ];\n    });\n    // The elements length and cached items length are different just after element is added/removed.\n    store._updateCacheLength(count);\n\n    const [startIndex, endIndex] = useSyncExternalStore(\n      store._subscribe,\n      store._getRange\n    );\n    const jump = useSyncExternalStore(store._subscribe, store._getJump);\n    const rootRef = useRef<HTMLDivElement>(null);\n\n    useIsomorphicLayoutEffect(() => {\n      const root = rootRef[refKey]!;\n      const unobserve = resizer._observeRoot(root);\n      const cleanup = scroller._initRoot(root);\n      return () => {\n        unobserve();\n        cleanup();\n      };\n    }, []);\n\n    useIsomorphicLayoutEffect(() => {\n      if (!jump.length) return;\n\n      scroller._fixScrollJump(jump, startIndex);\n    }, [jump]);\n\n    useEffect(() => {\n      if (!onRangeChangeProp) return;\n\n      onRangeChangeProp({\n        start: startIndex,\n        end: endIndex,\n        count,\n      });\n    }, [startIndex, endIndex]);\n\n    useImperativeHandle(\n      ref,\n      () => {\n        return {\n          get scrollOffset() {\n            return store._getScrollOffset();\n          },\n          get scrollSize() {\n            return scroller._getActualScrollSize();\n          },\n          get viewportSize() {\n            return store._getViewportSize();\n          },\n          scrollToIndex(index) {\n            scroller._scrollToIndex(index, count);\n          },\n          scrollTo: scroller._scrollTo,\n          scrollBy(offset) {\n            scroller._scrollTo(store._getScrollOffset() + offset);\n          },\n        };\n      },\n      [count]\n    );\n\n    const startIndexWithMargin = max(startIndex - overscan, 0);\n    const endIndexWithMargin = min(endIndex + overscan, count - 1);\n    const items = useMemo(() => {\n      const res: ReactElement[] = [];\n      for (let i = startIndexWithMargin; i <= endIndexWithMargin; i++) {\n        // https://github.com/sergi/virtual-list/commit/8e7e06dc63568334c1ab809ea83c1be36572e9ed\n        mountedIndexes.add(i);\n      }\n      mountedIndexes.forEach((i) => {\n        const e = elements[i];\n        // This can be undefined when items are removed\n        if (exists(e)) {\n          res.push(\n            <Item\n              key={(e as { key?: ReactElement[\"key\"] })?.key || i}\n              _resizer={resizer}\n              _store={store}\n              _index={i}\n              _element={itemElement as \"div\"}\n              _children={e}\n            />\n          );\n        }\n      });\n      return res;\n    }, [elements, mountedIndexes, startIndexWithMargin, endIndexWithMargin]);\n\n    return (\n      <Window\n        _ref={rootRef}\n        _store={store}\n        _element={element}\n        _scrolling={scrolling}\n        _children={items}\n        _attrs={windowAttrs}\n      />\n    );\n  }\n);\n","import {\n  ACTION_ITEM_RESIZE,\n  ACTION_WINDOW_RESIZE,\n  ItemResize,\n  VirtualStore,\n} from \"./store\";\nimport { exists, max, once } from \"./utils\";\n\nexport const createResizer = (store: VirtualStore) => {\n  let resized = false;\n  let rootElement: HTMLElement | undefined;\n  const sizeKey = store._isHorizontal() ? \"width\" : \"height\";\n  const mountedIndexes = new WeakMap<Element, number>();\n\n  // Initialize ResizeObserver lazily for SSR\n  const getResizeObserver = once(() => {\n    // https://www.w3.org/TR/resize-observer/#intro\n    return new ResizeObserver((entries) => {\n      const resizes: ItemResize[] = [];\n      for (const { target, contentRect } of entries) {\n        if (target === rootElement) {\n          store._update(ACTION_WINDOW_RESIZE, contentRect[sizeKey]);\n        } else {\n          const index = mountedIndexes.get(target);\n          if (exists(index)) {\n            resizes.push([index, contentRect[sizeKey]]);\n          }\n        }\n      }\n\n      if (resizes.length) {\n        store._update(ACTION_ITEM_RESIZE, resizes);\n        resized = true;\n      }\n    });\n  });\n\n  return {\n    _observeRoot(root: HTMLElement) {\n      rootElement = root;\n      const ro = getResizeObserver();\n      ro.observe(root);\n      return () => {\n        ro.disconnect();\n      };\n    },\n    _observeItem(el: HTMLElement, i: number) {\n      const ro = getResizeObserver();\n      mountedIndexes.set(el, i);\n      ro.observe(el);\n      return () => {\n        mountedIndexes.delete(el);\n        ro.unobserve(el);\n      };\n    },\n    _isJustResized(): boolean {\n      const prev = resized;\n      resized = false;\n      return prev;\n    },\n  };\n};\n\nexport type Resizer = ReturnType<typeof createResizer>;\n\nexport const createGridResizer = (\n  vStore: VirtualStore,\n  hStore: VirtualStore\n) => {\n  let heightResized = false;\n  let widthResized = false;\n  let rootElement: HTMLElement | undefined;\n\n  const heightKey = \"height\";\n  const widthKey = \"width\";\n  const mountedIndexes = new WeakMap<\n    Element,\n    [rowIndex: number, colIndex: number]\n  >();\n\n  type CellSize = [height: number, width: number];\n  const maybeCachedRowIndexes = new Set<number>();\n  const maybeCachedColIndexes = new Set<number>();\n  const sizeCache = new Map<string, CellSize>();\n  const getKey = (rowIndex: number, colIndex: number): string =>\n    `${rowIndex}-${colIndex}`;\n\n  // Initialize ResizeObserver lazily for SSR\n  const getResizeObserver = once(() => {\n    // https://www.w3.org/TR/resize-observer/#intro\n    return new ResizeObserver((entries) => {\n      const resizedRows = new Set<number>();\n      const resizedCols = new Set<number>();\n      for (const { target, contentRect } of entries) {\n        if (target === rootElement) {\n          vStore._update(ACTION_WINDOW_RESIZE, contentRect[heightKey]);\n          hStore._update(ACTION_WINDOW_RESIZE, contentRect[widthKey]);\n        } else {\n          const cell = mountedIndexes.get(target);\n          if (cell) {\n            const [rowIndex, colIndex] = cell;\n            const key = getKey(rowIndex, colIndex);\n            const prevSize = sizeCache.get(key);\n            const size: CellSize = [\n              contentRect[heightKey],\n              contentRect[widthKey],\n            ];\n            let rowResized: boolean | undefined;\n            let colResized: boolean | undefined;\n            if (!prevSize) {\n              rowResized = colResized = true;\n            } else {\n              if (prevSize[0] !== size[0]) {\n                rowResized = true;\n              }\n              if (prevSize[1] !== size[1]) {\n                colResized = true;\n              }\n            }\n            if (rowResized) {\n              resizedRows.add(rowIndex);\n            }\n            if (colResized) {\n              resizedCols.add(colIndex);\n            }\n            if (rowResized || colResized) {\n              sizeCache.set(key, size);\n            }\n          }\n        }\n      }\n\n      if (resizedRows.size) {\n        const heightResizes: ItemResize[] = [];\n        resizedRows.forEach((rowIndex) => {\n          let maxHeight = 0;\n          maybeCachedColIndexes.forEach((colIndex) => {\n            const size = sizeCache.get(getKey(rowIndex, colIndex));\n            if (size) {\n              maxHeight = max(maxHeight, size[0]);\n            }\n          });\n          if (maxHeight) {\n            heightResizes.push([rowIndex, maxHeight]);\n          }\n        });\n        vStore._update(ACTION_ITEM_RESIZE, heightResizes);\n        heightResized = true;\n      }\n      if (resizedCols.size) {\n        const widthResizes: ItemResize[] = [];\n        resizedCols.forEach((colIndex) => {\n          let maxWidth = 0;\n          maybeCachedRowIndexes.forEach((rowIndex) => {\n            const size = sizeCache.get(getKey(rowIndex, colIndex));\n            if (size) {\n              maxWidth = max(maxWidth, size[1]);\n            }\n          });\n          if (maxWidth) {\n            widthResizes.push([colIndex, maxWidth]);\n          }\n        });\n        hStore._update(ACTION_ITEM_RESIZE, widthResizes);\n        widthResized = true;\n      }\n    });\n  });\n\n  return {\n    _observeRoot(root: HTMLElement) {\n      rootElement = root;\n      const ro = getResizeObserver();\n      ro.observe(root);\n      return () => {\n        ro.disconnect();\n      };\n    },\n    _observeItem(el: HTMLElement, rowIndex: number, colIndex: number) {\n      const ro = getResizeObserver();\n      mountedIndexes.set(el, [rowIndex, colIndex]);\n      maybeCachedRowIndexes.add(rowIndex);\n      maybeCachedColIndexes.add(colIndex);\n      ro.observe(el);\n      return () => {\n        mountedIndexes.delete(el);\n        ro.unobserve(el);\n      };\n    },\n    _isJustResized(horizontal?: boolean): boolean {\n      const prev = horizontal ? widthResized : heightResized;\n      if (horizontal) {\n        widthResized = false;\n      } else {\n        heightResized = false;\n      }\n      return prev;\n    },\n  };\n};\n\nexport type GridResizer = ReturnType<typeof createGridResizer>;\n","import {\n  memo,\n  useRef,\n  useMemo,\n  CSSProperties,\n  ReactElement,\n  forwardRef,\n  ReactNode,\n  RefObject,\n  useState,\n} from \"react\";\nimport { VirtualStore, createVirtualStore } from \"../core/store\";\nimport { useIsomorphicLayoutEffect } from \"./useIsomorphicLayoutEffect\";\nimport { useSyncExternalStore } from \"./useSyncExternalStore\";\nimport { max, min } from \"../core/utils\";\nimport { createScroller } from \"../core/scroller\";\nimport { refKey } from \"./utils\";\nimport { useStatic } from \"./useStatic\";\nimport { WindowComponentAttributes } from \"..\";\nimport { createGridResizer, GridResizer } from \"../core/resizer\";\n\nconst genKey = (i: number, j: number) => `${i}-${j}`;\n\n/**\n * Props of customized cell component for {@link VGrid}.\n */\nexport interface CustomCellComponentProps {\n  style: CSSProperties;\n  children: ReactNode;\n}\n\nexport type CustomCellComponent = React.ForwardRefExoticComponent<\n  React.PropsWithoutRef<CustomCellComponentProps> & React.RefAttributes<any>\n>;\n\ntype CustomCellComponentOrElement =\n  | keyof JSX.IntrinsicElements\n  | CustomCellComponent;\n\ntype CellProps = {\n  _children: ReactNode;\n  _resizer: GridResizer;\n  _verticalStore: VirtualStore;\n  _horizontalStore: VirtualStore;\n  _rowIndex: number;\n  _colIndex: number;\n  _element: \"div\";\n};\n\nconst Cell = memo(\n  ({\n    _children: children,\n    _resizer: resizer,\n    _verticalStore: verticalStore,\n    _horizontalStore: horizontalStore,\n    _rowIndex: rowIndex,\n    _colIndex: colIndex,\n    _element: Element,\n  }: CellProps): ReactElement => {\n    const ref = useRef<HTMLDivElement>(null);\n\n    const top = useSyncExternalStore(verticalStore._subscribe, () =>\n      verticalStore._getItemOffset(rowIndex)\n    );\n    const left = useSyncExternalStore(horizontalStore._subscribe, () =>\n      horizontalStore._getItemOffset(colIndex)\n    );\n    const vHide = useSyncExternalStore(verticalStore._subscribe, () =>\n      verticalStore._isUnmeasuredItem(rowIndex)\n    );\n    const hHide = useSyncExternalStore(horizontalStore._subscribe, () =>\n      horizontalStore._isUnmeasuredItem(colIndex)\n    );\n    const height = useSyncExternalStore(verticalStore._subscribe, () =>\n      verticalStore._getItemSize(rowIndex)\n    );\n    const width = useSyncExternalStore(horizontalStore._subscribe, () =>\n      horizontalStore._getItemSize(colIndex)\n    );\n\n    // The index may be changed if elements are inserted to or removed from the start of props.children\n    useIsomorphicLayoutEffect(\n      () => resizer._observeItem(ref[refKey]!, rowIndex, colIndex),\n      [colIndex, rowIndex]\n    );\n\n    return (\n      <Element\n        ref={ref}\n        style={useMemo((): CSSProperties => {\n          const style: CSSProperties = {\n            display: \"grid\",\n            margin: 0,\n            padding: 0,\n            position: \"absolute\",\n            top: top,\n            [verticalStore._isRtl() ? \"right\" : \"left\"]: left,\n            visibility: vHide || hHide ? \"hidden\" : \"visible\",\n            minHeight: height,\n            minWidth: width,\n          };\n          return style;\n        }, [top, left, width, height, vHide, hHide])}\n      >\n        {children}\n      </Element>\n    );\n  }\n);\n\n/**\n * Props of customized scrollable component for {@link VGrid}.\n */\nexport interface CustomGridWindowComponentProps {\n  children: ReactNode;\n  scrollWidth: number;\n  scrollHeight: number;\n  scrolling: boolean;\n  attrs: WindowComponentAttributes;\n}\n\nconst DefaultWindow = forwardRef<any, CustomGridWindowComponentProps>(\n  (\n    { children, scrollWidth, scrollHeight, scrolling, attrs },\n    ref\n  ): ReactElement => {\n    return (\n      <div ref={ref} {...attrs}>\n        <div\n          style={useMemo((): CSSProperties => {\n            return {\n              position: \"relative\",\n              visibility: \"hidden\",\n              width: scrollWidth,\n              height: scrollHeight,\n              pointerEvents: scrolling ? \"none\" : \"auto\",\n            };\n          }, [scrollWidth, scrollHeight, scrolling])}\n        >\n          {children}\n        </div>\n      </div>\n    );\n  }\n);\n\nexport type CustomGridWindowComponent = typeof DefaultWindow;\n\nconst Window = ({\n  _children: children,\n  _ref: ref,\n  _vStore: vStore,\n  _hStore: hStore,\n  _element: Element,\n  _scrolling: scrolling,\n  _attrs: attrs,\n}: {\n  _children: ReactNode;\n  _ref: RefObject<HTMLDivElement>;\n  _vStore: VirtualStore;\n  _hStore: VirtualStore;\n  _element: CustomGridWindowComponent;\n  _scrolling: boolean;\n  _attrs: WindowComponentAttributes;\n}) => {\n  const height = useSyncExternalStore(vStore._subscribe, vStore._getScrollSize);\n  const width = useSyncExternalStore(hStore._subscribe, hStore._getScrollSize);\n\n  return (\n    <Element\n      ref={ref}\n      scrollWidth={width}\n      scrollHeight={height}\n      scrolling={scrolling}\n      attrs={useMemo(\n        () => ({\n          ...attrs,\n          style: {\n            overflow: \"auto\",\n            contain: \"strict\",\n            // transform: \"translate3d(0px, 0px, 0px)\",\n            // willChange: \"scroll-position\",\n            // backfaceVisibility: \"hidden\",\n            width: \"100%\",\n            height: \"100%\",\n            padding: 0,\n            margin: 0,\n            ...attrs.style,\n          },\n        }),\n        [attrs]\n      )}\n    >\n      {children}\n    </Element>\n  );\n};\n\n/**\n * Methods of {@link VGrid}.\n */\nexport interface VGridHandle {}\n\n/**\n * Props of {@link VGrid}.\n */\nexport interface VGridProps extends WindowComponentAttributes {\n  /**\n   * A function to create elements rendered by this component.\n   */\n  children: (arg: {\n    /**\n     * row index of cell\n     */\n    rowIndex: number;\n    /**\n     * column index of cell\n     */\n    colIndex: number;\n  }) => ReactNode;\n  /**\n   * Total row length of grid.\n   */\n  row: number;\n  /**\n   * Total column length of grid.\n   */\n  col: number;\n  /**\n   * Cell height hint for unmeasured items. It's recommended to specify this prop if item sizes are fixed and known, or much larger than the defaultValue. It will help to reduce scroll jump when items are measured.\n   * @defaultValue 40\n   */\n  cellHeight?: number;\n  /**\n   * Cell width hint for unmeasured items. It's recommended to specify this prop if item sizes are fixed and known, or much larger than the defaultValue. It will help to reduce scroll jump when items are measured.\n   * @defaultValue 100\n   */\n  cellWidth?: number;\n  /**\n   * Number of items to render above/below the visible bounds of the grid. You can increase to avoid showing blank items in fast scrolling.\n   * @defaultValue 2\n   */\n  overscan?: number;\n  /**\n   * If set, the specified amount of rows will be mounted in the initial rendering regardless of the container size. This prop is mostly for SSR.\n   */\n  initialRowCount?: number;\n  /**\n   * If set, the specified amount of cols will be mounted in the initial rendering regardless of the container size. This prop is mostly for SSR.\n   */\n  initialColCount?: number;\n  /**\n   * You have to set true if you use this component under `direction: rtl` style.\n   */\n  rtl?: boolean;\n  /**\n   * Customized element type for scrollable element. This element will get {@link CustomGridWindowComponentProps} as props.\n   * @defaultValue {@link DefaultWindow}\n   */\n  element?: CustomGridWindowComponent;\n  /**\n   * Customized element type for cell element. This element will get {@link CustomCellComponentProps} as props.\n   * @defaultValue \"div\"\n   */\n  cellElement?: CustomCellComponentOrElement;\n}\n\n/**\n * Virtualized grid component. See {@link VGridProps} and {@link VGridHandle}.\n */\nexport const VGrid = forwardRef<VGridHandle, VGridProps>(\n  (\n    {\n      children,\n      row: rowCount,\n      col: colCount,\n      cellHeight = 40,\n      cellWidth = 100,\n      overscan = 2,\n      initialRowCount,\n      initialColCount,\n      rtl: rtlProp,\n      element = DefaultWindow,\n      cellElement: itemElement = \"div\",\n      ...windowAttrs\n    },\n    _ref // TODO implement\n  ): ReactElement => {\n    const [verticalScrolling, setVerticalScrolling] = useState(false);\n    const [horizontalScrolling, setHorizontalScrolling] = useState(false);\n    // https://github.com/facebook/react/issues/25191#issuecomment-1237456448\n    const [vStore, hStore, resizer, vScroller, hScroller] = useStatic(() => {\n      const dummy = () => {};\n      const _vs = createVirtualStore(\n        rowCount,\n        cellHeight,\n        false,\n        !!rtlProp,\n        initialRowCount,\n        setVerticalScrolling,\n        dummy\n      );\n      const _hs = createVirtualStore(\n        colCount,\n        cellWidth,\n        true,\n        !!rtlProp,\n        initialColCount,\n        setHorizontalScrolling,\n        dummy\n      );\n      const resizer = createGridResizer(_vs, _hs);\n      return [\n        _vs,\n        _hs,\n        resizer,\n        createScroller(_vs, () => resizer._isJustResized()),\n        createScroller(_hs, () => resizer._isJustResized(true)),\n      ];\n    });\n    // The elements length and cached items length are different just after element is added/removed.\n    vStore._updateCacheLength(rowCount);\n    hStore._updateCacheLength(colCount);\n\n    const [startRowIndex, endRowIndex] = useSyncExternalStore(\n      vStore._subscribe,\n      vStore._getRange\n    );\n    const [startColIndex, endColIndex] = useSyncExternalStore(\n      hStore._subscribe,\n      hStore._getRange\n    );\n    const verticalJump = useSyncExternalStore(\n      vStore._subscribe,\n      vStore._getJump\n    );\n    const horizontalJump = useSyncExternalStore(\n      hStore._subscribe,\n      hStore._getJump\n    );\n    const rootRef = useRef<HTMLDivElement>(null);\n\n    useIsomorphicLayoutEffect(() => {\n      const root = rootRef[refKey]!;\n      const unobserve = resizer._observeRoot(root);\n      const vCleanup = vScroller._initRoot(root);\n      const hCleanup = hScroller._initRoot(root);\n      return () => {\n        unobserve();\n        vCleanup();\n        hCleanup();\n      };\n    }, []);\n\n    useIsomorphicLayoutEffect(() => {\n      if (verticalJump.length) {\n        vScroller._fixScrollJump(verticalJump, startRowIndex);\n      }\n    }, [verticalJump]);\n    useIsomorphicLayoutEffect(() => {\n      if (horizontalJump.length) {\n        hScroller._fixScrollJump(horizontalJump, startColIndex);\n      }\n    }, [horizontalJump]);\n\n    const render = useMemo(() => {\n      const cache = new Map<string, ReactNode>();\n      return (rowIndex: number, colIndex: number) => {\n        let e: ReactNode | undefined = cache.get(genKey(rowIndex, colIndex));\n        if (!e) {\n          cache.set(\n            genKey(rowIndex, colIndex),\n            (e = children({ rowIndex, colIndex }))\n          );\n        }\n        return e;\n      };\n    }, [children]);\n\n    const startRowIndexWithMargin = max(startRowIndex - overscan, 0);\n    const endRowIndexWithMargin = min(endRowIndex + overscan, rowCount - 1);\n    const startColIndexWithMargin = max(startColIndex - overscan, 0);\n    const endColIndexWithMargin = min(endColIndex + overscan, colCount - 1);\n    const items = useMemo(() => {\n      const res: ReactElement[] = [];\n      for (let i = startRowIndexWithMargin; i <= endRowIndexWithMargin; i++) {\n        for (let j = startColIndexWithMargin; j <= endColIndexWithMargin; j++) {\n          res.push(\n            <Cell\n              key={genKey(i, j)}\n              _resizer={resizer}\n              _verticalStore={vStore}\n              _horizontalStore={hStore}\n              _rowIndex={i}\n              _colIndex={j}\n              _element={itemElement as \"div\"}\n              _children={render(i, j)}\n            />\n          );\n        }\n      }\n\n      return res;\n    }, [\n      render,\n      startRowIndexWithMargin,\n      endRowIndexWithMargin,\n      startColIndexWithMargin,\n      endColIndexWithMargin,\n    ]);\n\n    return (\n      <Window\n        _ref={rootRef}\n        _vStore={vStore}\n        _hStore={hStore}\n        _element={element}\n        _scrolling={verticalScrolling || horizontalScrolling}\n        _children={items}\n        _attrs={windowAttrs}\n      />\n    );\n  }\n);\n"],"names":["min","Math","max","now","Date","exists","v","range","length","cb","Array","from","_","i","once","fn","called","cache","args","getItemSize","index","size","_sizes","_defaultItemSize","computeOffset","isTotal","_length","_measuredOffsetIndex","_offsets","top","computeStartOffset","findIndex","distance","sum","h","findStartIndexWithOffset","offset","prevStartIndex","prevOffset","findEndIndex","resetCache","itemSize","createVirtualStore","itemCount","isHorizontal","isRtl","initialItemCount","onScrollStateChange","onScrollOffsetChange","_scrollToQueue","viewportSize","scrollOffset","jump","scrollDirection","_prevRange","subscribers","Set","_getRange","prevEndIndex","start","end","_isUnmeasuredItem","_hasUnmeasuredItemsInRange","startIndex","hasUnmeasuredItemsInRange","endIndex","_getItemOffset","_getItemSize","_getScrollOffset","_getViewportSize","_getScrollSize","computeTotalSize","_getJump","_isHorizontal","_isRtl","_getItemIndexForScrollTo","_waitForScrollDestinationItemsMeasured","Promise","resolve","reject","then","undefined","_subscribe","add","delete","_update","type","payload","mutated","updated","filter","updatedJump","forEach","push","setItemSize","_getScrollDirection","_setScrollDirection","dir","prev","_updateCacheLength","useIsomorphicLayoutEffect","window","useLayoutEffect","useEffect","useSyncExternalStore","subscibe","getSnapShot","_useSyncExternalStore","hasNegativeOffsetInRtl","scrollable","key","isNegative","createScroller","store","isJustResized","rootElement","scrollToKey","getActualScrollSize","scrollWidth","scrollHeight","normalizeRtlOffset","diff","scrollTo","scrollManually","async","getCurrentOffset","getOffset","scrollSize","e","calcTotalJump","reduce","acc","j","_initRoot","root","syncViewportToScrollPosition","resized","onScrollStopped","debounce","id","cancel","clearTimeout","debouncedFn","setTimeout","_cancel","onScroll","onWheel","throttle","time","n","ctrlKey","deltaX","deltaY","addEventListener","passive","removeEventListener","_getActualScrollSize","_scrollTo","_scrollToIndex","count","_fixScrollJump","allDiff","refKey","useStatic","init","ref","useRef","useRefWithUpdate","value","Item","memo","_children","children","_resizer","resizer","_store","_index","_element","Element","hide","_observeItem","_jsx","style","useMemo","leftOrRightKey","margin","padding","position","visibility","display","DefaultWindow","forwardRef","scrolling","horizontal","attrs","width","height","pointerEvents","Window","Window$1","_ref","_scrolling","_attrs","overflow","contain","VList","itemSizeProp","overscan","horizontalProp","rtl","rtlProp","element","itemElement","onScrollProp","onScrollStop","onScrollStopProp","onRangeChange","onRangeChangeProp","windowAttrs","elements","arr","Children","isInvalidElement","mountedIndexes","reset","useState","setScrolling","scroller","isScrolling","sizeKey","WeakMap","getResizeObserver","ResizeObserver","entries","resizes","target","contentRect","get","_observeRoot","ro","observe","disconnect","el","set","unobserve","_isJustResized","createResizer","rootRef","cleanup","useImperativeHandle","scrollToIndex","scrollBy","startIndexWithMargin","endIndexWithMargin","items","res","genKey","Cell","_verticalStore","verticalStore","_horizontalStore","horizontalStore","_rowIndex","rowIndex","_colIndex","colIndex","left","vHide","hHide","minHeight","minWidth","_vStore","vStore","_hStore","hStore","VGrid","row","rowCount","col","colCount","cellHeight","cellWidth","initialRowCount","initialColCount","cellElement","verticalScrolling","setVerticalScrolling","horizontalScrolling","setHorizontalScrolling","vScroller","hScroller","dummy","_vs","_hs","createGridResizer","heightResized","widthResized","heightKey","widthKey","maybeCachedRowIndexes","maybeCachedColIndexes","sizeCache","Map","getKey","resizedRows","resizedCols","cell","prevSize","rowResized","colResized","heightResizes","maxHeight","widthResizes","maxWidth","startRowIndex","endRowIndex","startColIndex","endColIndex","verticalJump","horizontalJump","vCleanup","hCleanup","render","startRowIndexWithMargin","endRowIndexWithMargin","startColIndexWithMargin","endColIndexWithMargin"],"mappings":"oRAAO,MAAMA,EAAMC,KAAKD,IACXE,EAAMD,KAAKC,IACXC,EAAMC,KAAKD,IAEXE,EAAaC,GAAiD,MAALA,EAEzDC,EAAQA,CAAIC,EAAgBC,IACvCC,MAAMC,KAAK,CAAEH,WAAU,CAACI,EAAGC,IAAMJ,EAAGI,KAsCzBC,EAA2CC,IACtD,IAAIC,EACAC,EAEJ,MAAQ,IAAIC,KACLF,IACHA,GAAS,EACTC,EAAQF,KAAMG,IAETD,EACR,EC1CUE,EAAcA,CAACF,EAAcG,KACxC,MAAMC,EAAOJ,EAAMK,EAAOF,GAC1B,OAZsB,IAYfC,EAAoBJ,EAAMM,EAAmBF,CAAI,EAapDG,EAAgBA,CACpBP,EACAG,EACAK,KAEA,IAAKR,EAAMS,EAAS,OAAO,EAC3B,GAAIT,EAAMU,GAAwBP,EAChC,OAAIK,EACKR,EAAMW,EAASR,GAAUD,EAAYF,EAAOG,GAE5CH,EAAMW,EAASR,GAI1B,IAAIP,EAAII,EAAMU,EACVE,EAAMZ,EAAMW,EAASf,GACzB,KAAOA,GAAKO,IACVH,EAAMW,EAASf,GAAKgB,EAChBhB,IAAMO,GAAUK,IAGpBI,GAAOV,EAAYF,EAAOJ,GAC1BA,IAIF,OADAI,EAAMU,EAAuBP,EACtBS,CAAG,EAOCC,EAAqBA,CAChCb,EACAG,IAEOI,EAAcP,EAAOG,GAGxBW,EAAYA,CAACd,EAAcJ,EAAWmB,KAC1C,IAAIC,EAAM,EACV,GAAID,GAAY,EAEd,KAAOnB,EAAII,EAAMS,EAAU,GAAG,CAC5B,MAAMQ,EAAIf,EAAYF,EAAOJ,KAC7B,IAAKoB,GAAOC,IAAMF,EAAU,CACtBC,EAAMC,EAAI,GAAKF,GACjBnB,IAEF,KACD,CACF,MAGD,KAAOA,EAAI,GAAG,CACZ,MAAMqB,EAAIf,EAAYF,IAASJ,GAC/B,IAAKoB,GAAOC,IAAMF,EAAU,CACtBC,EAAMC,EAAI,EAAIF,GAChBnB,IAEF,KACD,CACF,CAGH,OAAOb,EAAIE,EAAIW,EAAG,GAAII,EAAMS,EAAU,EAAE,EAG7BS,EAA2BA,CACtClB,EACAmB,EACAC,EACAC,IAEOP,EAAUd,EAAOoB,EAAgBD,EAASE,GAGtCC,EAAeR,EAefS,EAAaA,CACxBhC,EACAiC,EACAxB,KAEO,CACLM,EAAkBkB,EAClBf,EAASlB,EACTmB,EAAsBV,EAClBjB,EAAIiB,EAAMU,EAAsBnB,EAAS,GACzC,EACJc,EAAQf,EAAMC,GAASK,IACrB,MAAMQ,EAAOJ,GAASA,EAAMK,EAAOT,GACnC,OAAIR,EAAOgB,GACFA,GApIS,CAsIH,IAEjBO,EAAUrB,EAAMC,GAASK,IACvB,GAAU,IAANA,EAEF,OAAO,EAET,MAAMuB,EAASnB,GAASA,EAAMW,EAASf,GACvC,OAAIR,EAAO+B,GACFA,GA/IS,CAiJH,MCtFRM,EAAqBA,CAChCC,EACAF,EACAG,EACAC,EACAC,EAA2B,EAC3BC,EACAC,KAEA,IAMIC,EANAC,EAAeT,EAAWvC,EAAI4C,EAAmB,EAAG,GACpDK,EAAe,EACfC,EAAmB,GACnBnC,EAAQuB,EAAWG,EAAWF,GAC9BY,EAvDqB,EAwDrBC,EAAyB,CAAC,EAAGR,GAGjC,MAAMS,EAAc,IAAIC,IAExB,MAAO,CACLC,IACE,MAAOpB,EAAgBqB,GAAgBJ,EACjChB,EAAaR,EACjBb,EACAoB,GAEIsB,EAAQxB,EACZlB,EACAkC,EACAd,EACAC,GAEIsB,EAAMrB,EAAatB,EAAO0C,EAAOT,GACvC,OAAIb,IAAmBsB,GAASD,IAAiBE,EACxCN,EAEDA,EAAa,CAACK,EAAOC,EAC9B,EACDC,EAAkBzC,IDjGE,ICkGXH,EAAMK,EAAOF,GAEtB0C,EAA2BC,GDKUC,EACvC/C,EACA8C,EACAE,KAEA,IAAK,IAAIpD,EAAIkD,EAAYlD,GAAKoD,EAAUpD,IACtC,IA/GoB,IA+GhBI,EAAMK,EAAOT,GACf,OAAO,EAGX,OAAO,CAAK,ECdDmD,CACL/C,EACA8C,EACAxB,EAAatB,EAAO8C,EAAYb,IAGpCgB,EAAe9C,GACNU,EAAmBb,EAA2BG,GAEvD+C,EAAa/C,GACJD,EAAYF,EAAOG,GAE5BgD,EAAgBA,IACPjB,EAETkB,EAAgBA,IACPnB,EAEToB,EAAcA,IDjEerD,IACxBO,EAAcP,EAAOA,EAAMS,EAAU,GAAG,GCiEpC6C,CAAiBtD,GAE1BuD,EAAQA,IACCpB,EAETqB,EAAaA,IACJ7B,EAET8B,EAAMA,IACG7B,EAET8B,EAAyBvC,GAChBD,EAAyBlB,EAAOmB,EAAQ,EAAG,GAEpDwC,EAAsCA,KAChC3B,GAEFA,EAAe,KAIV,IAAI4B,SAAQ,CAACC,EAASC,KAC3B9B,EAAiB,CACf,KAEE4B,QAAQC,UAAUE,MAAK,KACrBF,IACA7B,OAAiBgC,CAAS,GAC1B,EAEJF,EACD,KAGLG,EAAWzE,IACT8C,EAAY4B,IAAI1E,GACT,KACL8C,EAAY6B,OAAO3E,EAAG,GAG1B4E,EAAQC,EAAMC,GACZ,MAAMC,EAAU,MACd,OAAQF,GACN,KAxIwB,EAwIC,CACvB,MAAMG,EAAUF,EAAQG,QACtB,EAAEtE,EAAOC,KAAUJ,EAAMK,EAAOF,KAAWC,IAG7C,IAAKoE,EAAQjF,OACX,OAAO,EAGT,MAAMmF,EAA0B,GAMhC,OALAF,EAAQG,SAAQ,EAAExE,EAAOC,MACvBsE,EAAYE,KAAK,CAACxE,EAAOF,EAAYF,EAAOG,GAAQA,ID/JvC0E,EACzB7E,EACAG,EACAC,KAEAJ,EAAMK,EAAOF,GAASC,EAEtBJ,EAAMU,EAAuB3B,EAAIoB,EAAOH,EAAMU,EAAqB,ECyJvDmE,CAAY7E,EAA2BG,EAAOC,EAAK,IAErD+B,EAAOuC,GACA,CACR,CACD,KAxJ0B,EAyJxB,OAAIzC,IAAiBqC,IAGrBrC,EAAeqC,GACR,GAET,KA9JmB,EA+JnB,KA9J0B,EA8JC,CACzB,MAAMjD,EAAaa,EACnB,OAAQA,EAAeoC,KAAajD,CACrC,EAEJ,EAhCe,GAkCZkD,IACFjC,EAAYqC,SAASnF,IACnBA,GAAI,IAxKe,IA2KjB6E,EACFtC,EAAqBG,GACZF,GA/Ke,IA+KGqC,GAC3BrC,EAAe,KAGpB,EACD8C,EAAmBA,IACV1C,EAET2C,EAAoBC,GAClB,MAAMC,EAAO7C,EACbA,EAAkB4C,EAnMG,IAoMjB5C,EACFN,GAAoB,GArMD,IAuMnBmD,GAtMmB,IAuMlB7C,GAtMgB,IAsMmBA,GAEpCN,GAAoB,EAEvB,EACDoD,EAAmB3F,GAEbS,EAAMS,IAAYlB,IACtBS,EAAQuB,EAAWhC,EAAQiC,EAAUxB,GACtC,EACF,ECnOUmF,EACO,oBAAXC,OAAyBC,EAAkBC,ECFvCC,EAAuBA,CAClCC,EACAC,IAEOC,EAAsBF,EAAUC,EAAaA,GCEzCE,EAAyB9F,GAAM+F,IAC1C,MAAMC,EAAM,aACNZ,EAAOW,EAAWC,GACxBD,EAAWC,GAAO,EAElB,MAAMC,EAAaF,EAAWC,GAAO,EAErC,OADAD,EAAWC,GAAOZ,EACXa,CAAU,ICMNC,EAAiBA,CAC5BC,EACAC,KAEA,IAAIC,EACJ,MAAMvE,EAAeqE,EAAMxC,IACrB5B,EAAQoE,EAAMvC,IACd0C,EAAcxE,EAAe,aAAe,YAE5CyE,EAAsBA,IACrBF,EAGEvE,EAAeuE,EAAYG,YAAcH,EAAYI,aAHnC,EAKrBC,EAAqBA,CAACpF,EAAgBqF,IACtCb,EAAuBO,IAGlBM,GAFCrF,EAIJ6E,EAAM3C,IAAmB2C,EAAM5C,IAAqBjC,EAGtDsF,EAAWA,CAACtF,EAAgBqF,KAC3BN,IACDvE,GAAgBC,IAClBT,EAASoF,EAAmBpF,EAAQqF,IAElCA,EACFN,EAAYC,IAAgBhF,GAE5B+E,EAAYC,GAAehF,EAC3B6E,EAAMjB,EJ/BiB,IIgCxB,EAEG2B,EAAiBC,MACrBxG,EACAyG,KAEA,MAAMC,EAAYA,KAChB,IAAI1F,EAASyF,IACb,MAAME,EAAaV,IACbnE,EAAe+D,EAAM5C,IAK3B,OAJI0D,GAAc3F,EAASc,IAAiB,IAE1Cd,EAAS2F,EAAa7E,GAEjBd,CAAM,EAGf,GAAI6E,EAAMnD,EAA2B1C,GAAQ,CAC3C,EAAG,CAED6F,EAAM5B,EJ1CsB,EI0CQyC,KACpC,UAEQb,EAAMrC,GACb,CAAC,MAAOoD,GAEP,MACD,CACF,OAAQf,EAAMnD,EAA2B1C,IAG1CsG,EAASI,IACV,KAAM,CACL,MAAM1F,EAAS0F,IACfJ,EAAStF,GAET6E,EAAM5B,EJ1DwB,EI0DMjD,EACrC,GAGG6F,EAAiB7E,GACrBA,EAAK8E,QAAO,CAACC,GAAMC,KAAOD,EAAMC,GAAG,GAErC,MAAO,CACLC,EAAUC,GACRnB,EAAcmB,EAEd,MAAMC,EAA+BA,KACnC,IAAInG,EAASkG,EAAKlB,GACdxE,GAAgBC,IAClBT,EAASoF,EAAmBpF,IAE9B,MAAME,EAAa2E,EAAM7C,IACzB,GAAI9B,IAAeF,EACjB,OAEF,MAAMiB,EAAkB4D,EAAMlB,IAGxByC,EAAUtB,IJ9FG,IIgGhB7D,GAAoCmF,GJ7FlB,II+FnBnF,GAEA4D,EAAMjB,EACJ1D,EAAaF,EJnGA,EADE,GIuGnB6E,EAAM5B,EJ5Fe,EI4FQjD,EAAO,EAGhCqG,ENtHYC,MAItB,IAAIC,EAEJ,MAAMC,EAASA,KACTvI,EAAOsI,IACTE,aAAaF,EACd,EAEGG,EAAcA,KAClBF,IACAD,EAAKI,YAAW,KACdJ,EAAK,KM0GHJ,IACAtB,EAAMjB,EJ9Ga,EFIjB,GM2GD,IN1GC,EAGR,OADA8C,EAAYE,EAAUJ,EACfE,CAAW,EMmGUJ,GAMlBO,EAAWA,KACfV,IACAE,GAAiB,EAKbS,EN7GYC,MAItB,IAAIC,EAAOjJ,IM8HJ,GN7HP,MAAO,IAAIe,KACT,MAAMmI,EAAIlJ,IACNiJ,EM2HC,GN3HWC,IACdD,EAAOC,EMqGmBrB,KACxB,GJzHmB,IIyHff,EAAMlB,MAINiC,EAAEsB,UAOF1G,EAAeoF,EAAEuB,OAASvB,EAAEwB,QAAQ,CACtC,MAAMpH,EAAS6E,EAAM7C,IAEnBhC,EAAS,GACTA,EAAS6E,EAAM3C,IAAmB2C,EAAM5C,KAExCoE,GAEH,GNxHH1H,IAAMG,GACP,CACF,EMkGmBiI,GA0BhB,OAHAb,EAAKmB,iBAAiB,SAAUR,GAChCX,EAAKmB,iBAAiB,QAASP,EAAS,CAAEQ,SAAS,IAE5C,KACLpB,EAAKqB,oBAAoB,SAAUV,GACnCX,EAAKqB,oBAAoB,QAAST,GAClCT,EAAgBO,GAAS,CAE5B,EACDY,EAAsBvC,EACtBwC,EAAUzH,GACRA,EAASlC,EAAIkC,EAAQ,GAErBuF,EAAeV,EAAMtC,EAAyBvC,IAAS,IAAMA,GAC9D,EACD0H,EAAe1I,EAAO2I,GACpB3I,EAAQlB,EAAIF,EAAIoB,EAAO2I,EAAQ,GAAI,GAEnCpC,EAAevG,GAAO,IAAM6F,EAAM/C,EAAe9C,IAClD,EACD4I,EAAgBA,CAAC5G,EAAMW,KACrB,MAAMV,EAAkB4D,EAAMlB,IAE9B,GJpKmB,IIoKf1C,EAA+B,CACjC,MAAMoE,EAAOQ,EAAc7E,GACvBqE,GACFC,EAASD,GAAM,EAElB,MAAM,GJxKgB,IIwKZpE,EAAmC,CAC5C,MAAMjB,EAAS6E,EAAM7C,IACrB,GAAe,IAAXhC,OAEG,CACL,MAAM6H,EAAUhC,EAAc7E,GAC9B,GACE6D,EAAM3C,KACHlC,EAAS6E,EAAM5C,IAAqB4F,IACvC,EAGIA,GACFvC,EAAStF,EAAS6H,OAEf,CAEL,MAAMxC,EAAOrE,EAAK8E,QAAO,CAACC,GAAMC,EAAGhH,MAC7BA,EAAQ2C,IACVoE,GAAOC,GAEFD,IACN,GACCV,GACFC,EAASD,GAAM,EAElB,CACF,CACF,CAAM,EAIV,EC5NUyC,EAAS,UCATC,EAAgBC,IAC3B,MAAMC,EAAMC,IACZ,OAAOD,EAAIH,KAAYG,EAAIH,GAAUE,IAAO,ECDjCG,EAAuBC,IAClC,MAAMH,EAAMC,EAAUE,GAMtB,OAJApE,GAA0B,KACxBiE,EAAIH,GAAUM,CAAK,GAClB,CAACA,IAEGH,CAAG,ECuBNI,eAAOC,GACX,EACEC,EAAWC,EACXC,EAAUC,EACVC,EAAQ9D,EACR+D,EAAQ5J,EACR6J,EAAUC,MAEV,MAAMb,EAAMC,EAAuB,MAE7BlI,EAASoE,EAAqBS,EAAM/B,GAAY,IACpD+B,EAAM/C,EAAe9C,KAEjB+J,EAAO3E,EAAqBS,EAAM/B,GAAY,IAClD+B,EAAMpD,EAAkBzC,KAS1B,OALAgF,GACE,IAAM0E,EAAQM,EAAaf,EAAIH,GAAU9I,IACzC,CAACA,IAIDiK,EAACH,EAAO,CACNb,IAAKA,EACLiB,MAAOC,GAAQ,KACb,MAAM3I,EAAeqE,EAAMxC,IACrB+G,EAAiBvE,EAAMvC,IAAW,QAAU,OAC5C4G,EAAuB,CAC3BG,OAAQ,EACRC,QAAS,EACTC,SAAU,WACV,CAAC/I,EAAe,SAAW,SAAU,OACrC,CAACA,EAAe,MAAQ4I,GAAiB,EACzC,CAAC5I,EAAe4I,EAAiB,OAAQpJ,EACzCwJ,WAAYT,EAAO,SAAW,WAMhC,OAHIvI,IACF0I,EAAMO,QAAU,QAEXP,CAAK,GACX,CAAClJ,EAAQ+I,IAEXP,SAAAA,GACO,IAgBVkB,eAAgBC,GACpB,EACInB,WAAU7C,aAAYiE,YAAWC,aAAYC,SAC/C7B,IAGEgB,EAAA,MAAA,CAAKhB,IAAKA,KAAS6B,EACjBtB,SAAAS,EAAA,MAAA,CACEC,MAAOC,GAAQ,KACN,CACLI,SAAU,WACVC,WAAY,SACZO,MAAOF,EAAalE,EAAa,OACjCqE,OAAQH,EAAa,OAASlE,EAC9BsE,cAAeL,EAAY,OAAS,UAErC,CAACjE,EAAYiE,IAAWpB,SAE1BA,QASL0B,EAASC,EACb5B,EAAWC,EACX4B,EAAMnC,EACNU,EAAQ9D,EACRgE,EAAUC,EACVuB,EAAYT,EACZU,EAAQR,MASR,MAAMnE,EAAavB,EACjBS,EAAM/B,EACN+B,EAAM3C,GAGF2H,EAAahF,EAAMxC,IAEzB,OACE4G,EAACH,EACC,CAAAb,IAAKA,EACLtC,WAAYA,EACZiE,UAAWA,EACXC,WAAYA,EACZC,MAAOX,GACL,KAAO,IACFW,EACHZ,MAAO,CACLqB,SAAUV,EAAa,cAAgB,cACvCW,QAAS,SAITT,MAAO,OACPC,OAAQ,OACRV,QAAS,EACTD,OAAQ,KACLS,EAAMZ,UAGb,CAACY,IAGFtB,SAAAA,GACO,EA4HDiC,eAAQd,GACnB,EAEInB,WACAnI,SAAUqK,EAAe,GACzBC,WAAW,EACXjK,mBACAmJ,WAAYe,EACZC,IAAKC,EACLC,UAAUrB,EACVsB,cAAc,MACdnE,SAAUoE,EACVC,aAAcC,EACdC,cAAeC,KACZC,GAELrD,KAGA,MAAMsD,EAAWpC,GAAQ,KACvB,MAAMqC,EAA0D,GAOhE,OANAC,EAASjI,QAAQgF,GAAW5C,IHtThCA,KAEC3H,EAAO2H,IAAmB,kBAANA,EGqTX8F,CAAiB9F,IAGrB4F,EAAI/H,KAAKmC,EAAE,IAEN4F,CAAG,GACT,CAAChD,IACEb,EAAQ4D,EAASnN,OAEjByI,EAAWsB,EAAiB8C,GAC5BC,EAAe/C,EAAiBgD,IAE/BQ,EAAgBC,GAASC,EAAsB,IAAIzK,MACnDwI,EAAWkC,GAAgBD,GAAS,IAEpChH,EAAO6D,EAASqD,GAAYhE,GAAU,KAC3C,MAAMY,EAASrI,EACbqH,EACA+C,IACEE,IACAE,EACFpK,GACCsL,IACCF,EAAaE,GACRA,IACHJ,EAAM,IAAIxK,KACV8J,EAAapD,IAAWoD,EAAapD,KACtC,IAEF9H,IACC6G,EAASiB,IAAWjB,EAASiB,GAAQ9H,EAAO,IAG1CyI,ECtVkB5D,KAC5B,IACIE,EADAqB,GAAU,EAEd,MAAM6F,EAAUpH,EAAMxC,IAAkB,QAAU,SAC5CsJ,EAAiB,IAAIO,QAGrBC,EAAoBzN,GAAK,IAEtB,IAAI0N,gBAAgBC,IACzB,MAAMC,EAAwB,GAC9B,IAAK,MAAMC,OAAEA,EAAMC,YAAEA,KAAiBH,EACpC,GAAIE,IAAWxH,EACbF,EAAM5B,ETUoB,ESVUuJ,EAAYP,QAC3C,CACL,MAAMjN,EAAQ2M,EAAec,IAAIF,GAC7BtO,EAAOe,IACTsN,EAAQ7I,KAAK,CAACzE,EAAOwN,EAAYP,IAEpC,CAGCK,EAAQlO,SACVyG,EAAM5B,ETDoB,ESCQqJ,GAClClG,GAAU,EACX,MAIL,MAAO,CACLsG,EAAaxG,GACXnB,EAAcmB,EACd,MAAMyG,EAAKR,IAEX,OADAQ,EAAGC,QAAQ1G,GACJ,KACLyG,EAAGE,YAAY,CAElB,EACD7D,EAAa8D,EAAiBrO,GAC5B,MAAMkO,EAAKR,IAGX,OAFAR,EAAeoB,IAAID,EAAIrO,GACvBkO,EAAGC,QAAQE,GACJ,KACLnB,EAAe3I,OAAO8J,GACtBH,EAAGK,UAAUF,EAAG,CAEnB,EACDG,KACE,MAAMnJ,EAAOsC,EAEb,OADAA,GAAU,EACHtC,CACR,EACF,EDkSoBoJ,CAAcvE,GAC/B,MAAO,CACLA,EACAF,EACA7D,EAAe+D,EAAQF,EAASwE,IACjC,IAGHpI,EAAMd,EAAmB4D,GAEzB,MAAOhG,EAAYE,GAAYuC,EAC7BS,EAAM/B,EACN+B,EAAMxD,GAEFL,EAAOoD,EAAqBS,EAAM/B,EAAY+B,EAAMzC,GACpD+K,EAAUjF,EAAuB,MAEvClE,GAA0B,KACxB,MAAMkC,EAAOiH,EAAQrF,GACfkF,EAAYtE,EAAQgE,EAAaxG,GACjCkH,EAAUrB,EAAS9F,EAAUC,GACnC,MAAO,KACL8G,IACAI,GAAS,CACV,GACA,IAEHpJ,GAA0B,KACnBhD,EAAK5C,QAEV2N,EAASnE,EAAe5G,EAAMW,EAAW,GACxC,CAACX,IAEJmD,GAAU,KACHkH,GAELA,EAAkB,CAChB9J,MAAOI,EACPH,IAAKK,EACL8F,SACA,GACD,CAAChG,EAAYE,IAEhBwL,EACEpF,GACA,KACS,CACDlH,mBACF,OAAO8D,EAAM7C,GACd,EACG2D,iBACF,OAAOoG,EAASvE,GACjB,EACG1G,mBACF,OAAO+D,EAAM5C,GACd,EACDqL,cAActO,GACZ+M,EAASrE,EAAe1I,EAAO2I,EAChC,EACDrC,SAAUyG,EAAStE,EACnB8F,SAASvN,GACP+L,EAAStE,EAAU5C,EAAM7C,IAAqBhC,EAC/C,KAGL,CAAC2H,IAGH,MAAM6F,EAAuB1P,EAAI6D,EAAagJ,EAAU,GAClD8C,EAAqB7P,EAAIiE,EAAW8I,EAAUhD,EAAQ,GACtD+F,EAAQvE,GAAQ,KACpB,MAAMwE,EAAsB,GAC5B,IAAK,IAAIlP,EAAI+O,EAAsB/O,GAAKgP,EAAoBhP,IAE1DkN,EAAe5I,IAAItE,GAkBrB,OAhBAkN,EAAenI,SAAS/E,IACtB,MAAMmH,EAAI2F,EAAS9M,GAEfR,EAAO2H,IACT+H,EAAIlK,KACFwF,EAACZ,GAECI,EAAUC,EACVC,EAAQ9D,EACR+D,EAAQnK,EACRoK,EAAUmC,EACVzC,EAAW3C,IALLA,aAAC,EAADA,EAAqClB,MAAOjG,GAQvD,IAEIkP,CAAG,GACT,CAACpC,EAAUI,EAAgB6B,EAAsBC,IAEpD,OACExE,EAACiB,EAAM,CACLE,EAAM+C,EACNxE,EAAQ9D,EACRgE,EAAUkC,EACVV,EAAYT,EACZrB,EAAWmF,EACXpD,EAAQgB,GACR,IEhbFsC,EAASA,CAACnP,EAAWuH,IAAiB,GAAAvH,KAAKuH,IA4B3C6H,eAAOvF,GACX,EACEC,EAAWC,EACXC,EAAUC,EACVoF,GAAgBC,EAChBC,GAAkBC,EAClBC,GAAWC,EACXC,GAAWC,EACXxF,EAAUC,MAEV,MAAMb,EAAMC,EAAuB,MAE7BzI,EAAM2E,EAAqB2J,EAAcjL,GAAY,IACzDiL,EAAcjM,EAAeqM,KAEzBG,EAAOlK,EAAqB6J,EAAgBnL,GAAY,IAC5DmL,EAAgBnM,EAAeuM,KAE3BE,EAAQnK,EAAqB2J,EAAcjL,GAAY,IAC3DiL,EAActM,EAAkB0M,KAE5BK,EAAQpK,EAAqB6J,EAAgBnL,GAAY,IAC7DmL,EAAgBxM,EAAkB4M,KAE9BrE,EAAS5F,EAAqB2J,EAAcjL,GAAY,IAC5DiL,EAAchM,EAAaoM,KAEvBpE,EAAQ3F,EAAqB6J,EAAgBnL,GAAY,IAC7DmL,EAAgBlM,EAAasM,KAS/B,OALArK,GACE,IAAM0E,EAAQM,EAAaf,EAAIH,GAAUqG,EAAUE,IACnD,CAACA,EAAUF,IAIXlF,EAACH,EAAO,CACNb,IAAKA,EACLiB,MAAOC,GAAQ,KACgB,CAC3BM,QAAS,OACTJ,OAAQ,EACRC,QAAS,EACTC,SAAU,WACV9J,IAAKA,EACL,CAACsO,EAAczL,IAAW,QAAU,QAASgM,EAC7C9E,WAAY+E,GAASC,EAAQ,SAAW,UACxCC,UAAWzE,EACX0E,SAAU3E,KAGX,CAACtK,EAAK6O,EAAMvE,EAAOC,EAAQuE,EAAOC,aAEpChG,GACO,IAgBVkB,eAAgBC,GACpB,EACInB,WAAUtD,cAAaC,eAAcyE,YAAWE,SAClD7B,IAGEgB,EAAA,MAAA,CAAKhB,IAAKA,KAAS6B,EACjBtB,SAAAS,EAAA,MAAA,CACEC,MAAOC,GAAQ,KACN,CACLI,SAAU,WACVC,WAAY,SACZO,MAAO7E,EACP8E,OAAQ7E,EACR8E,cAAeL,EAAY,OAAS,UAErC,CAAC1E,EAAaC,EAAcyE,IAE9BpB,SAAAA,QASL0B,EAASA,EACb3B,EAAWC,EACX4B,EAAMnC,EACN0G,GAASC,EACTC,GAASC,EACTjG,EAAUC,EACVuB,EAAYT,EACZU,EAAQR,MAUR,MAAME,EAAS5F,EAAqBwK,EAAO9L,EAAY8L,EAAO1M,GACxD6H,EAAQ3F,EAAqB0K,EAAOhM,EAAYgM,EAAO5M,GAE7D,OACE+G,EAACH,EACC,CAAAb,IAAKA,EACL/C,YAAa6E,EACb5E,aAAc6E,EACdJ,UAAWA,EACXE,MAAOX,GACL,KAAO,IACFW,EACHZ,MAAO,CACLqB,SAAU,OACVC,QAAS,SAITT,MAAO,OACPC,OAAQ,OACRV,QAAS,EACTD,OAAQ,KACLS,EAAMZ,UAGb,CAACY,IAGFtB,SAAAA,GACO,EA4EDuG,eAAQpF,GACnB,EAEInB,WACAwG,IAAKC,EACLC,IAAKC,EACLC,aAAa,GACbC,YAAY,IACZ1E,WAAW,EACX2E,kBACAC,kBACA1E,IAAKC,EACLC,UAAUrB,EACV8F,YAAaxE,EAAc,SACxBM,MAIL,MAAOmE,EAAmBC,GAAwB7D,GAAS,IACpD8D,EAAqBC,GAA0B/D,GAAS,IAExD+C,EAAQE,EAAQpG,EAASmH,EAAWC,GAAa/H,GAAU,KAChE,MAAMgI,EAAQA,OACRC,EAAM1P,EACV2O,EACAG,GACA,IACEtE,EACFwE,EACAI,EACAK,GAEIE,EAAM3P,EACV6O,EACAE,GACA,IACEvE,EACFyE,EACAK,EACAG,GAEIrH,EDtPqBwH,EAC/BtB,EACAE,KAEA,IAEI/J,EAFAoL,GAAgB,EAChBC,GAAe,EAGnB,MAAMC,EAAY,SACZC,EAAW,QACX3E,EAAiB,IAAIO,QAMrBqE,EAAwB,IAAInP,IAC5BoP,EAAwB,IAAIpP,IAC5BqP,EAAY,IAAIC,IAChBC,EAASA,CAACxC,EAAkBE,IAC7B,GAAAF,KAAYE,IAGXlC,EAAoBzN,GAAK,IAEtB,IAAI0N,gBAAgBC,IACzB,MAAMuE,EAAc,IAAIxP,IAClByP,EAAc,IAAIzP,IACxB,IAAK,MAAMmL,OAAEA,EAAMC,YAAEA,KAAiBH,EACpC,GAAIE,IAAWxH,EACb6J,EAAO3L,EThEmB,ESgEWuJ,EAAY6D,IACjDvB,EAAO7L,ETjEmB,ESiEWuJ,EAAY8D,QAC5C,CACL,MAAMQ,EAAOnF,EAAec,IAAIF,GAChC,GAAIuE,EAAM,CACR,MAAO3C,EAAUE,GAAYyC,EACvBpM,EAAMiM,EAAOxC,EAAUE,GACvB0C,EAAWN,EAAUhE,IAAI/H,GACzBzF,EAAiB,CACrBuN,EAAY6D,GACZ7D,EAAY8D,IAEd,IAAIU,EACAC,EACCF,GAGCA,EAAS,KAAO9R,EAAK,KACvB+R,GAAa,GAEXD,EAAS,KAAO9R,EAAK,KACvBgS,GAAa,IANfD,EAAaC,GAAa,EASxBD,GACFJ,EAAY7N,IAAIoL,GAEd8C,GACFJ,EAAY9N,IAAIsL,IAEd2C,GAAcC,IAChBR,EAAU1D,IAAIrI,EAAKzF,EAEtB,CACF,CAGH,GAAI2R,EAAY3R,KAAM,CACpB,MAAMiS,EAA8B,GACpCN,EAAYpN,SAAS2K,IACnB,IAAIgD,EAAY,EAChBX,EAAsBhN,SAAS6K,IAC7B,MAAMpP,EAAOwR,EAAUhE,IAAIkE,EAAOxC,EAAUE,IACxCpP,IACFkS,EAAYrT,EAAIqT,EAAWlS,EAAK,IACjC,IAECkS,GACFD,EAAczN,KAAK,CAAC0K,EAAUgD,GAC/B,IAEHvC,EAAO3L,ETpHmB,ESoHSiO,GACnCf,GAAgB,CACjB,CACD,GAAIU,EAAY5R,KAAM,CACpB,MAAMmS,EAA6B,GACnCP,EAAYrN,SAAS6K,IACnB,IAAIgD,EAAW,EACfd,EAAsB/M,SAAS2K,IAC7B,MAAMlP,EAAOwR,EAAUhE,IAAIkE,EAAOxC,EAAUE,IACxCpP,IACFoS,EAAWvT,EAAIuT,EAAUpS,EAAK,IAC/B,IAECoS,GACFD,EAAa3N,KAAK,CAAC4K,EAAUgD,GAC9B,IAEHvC,EAAO7L,ETrImB,ESqISmO,GACnChB,GAAe,CAChB,OAIL,MAAO,CACL1D,EAAaxG,GACXnB,EAAcmB,EACd,MAAMyG,EAAKR,IAEX,OADAQ,EAAGC,QAAQ1G,GACJ,KACLyG,EAAGE,YAAY,CAElB,EACD7D,EAAa8D,EAAiBqB,EAAkBE,GAC9C,MAAM1B,EAAKR,IAKX,OAJAR,EAAeoB,IAAID,EAAI,CAACqB,EAAUE,IAClCkC,EAAsBxN,IAAIoL,GAC1BqC,EAAsBzN,IAAIsL,GAC1B1B,EAAGC,QAAQE,GACJ,KACLnB,EAAe3I,OAAO8J,GACtBH,EAAGK,UAAUF,EAAG,CAEnB,EACDG,GAAepD,GACb,MAAM/F,EAAO+F,EAAauG,EAAeD,EAMzC,OALItG,EACFuG,GAAe,EAEfD,GAAgB,EAEXrM,CACR,EACF,ECiHmBoM,CAAkBF,EAAKC,GACvC,MAAO,CACLD,EACAC,EACAvH,EACA9D,EAAeoL,GAAK,IAAMtH,EAAQuE,OAClCrI,EAAeqL,GAAK,IAAMvH,EAAQuE,IAAe,KAClD,IAGH2B,EAAO7K,EAAmBkL,GAC1BH,EAAO/K,EAAmBoL,GAE1B,MAAOmC,EAAeC,GAAenN,EACnCwK,EAAO9L,EACP8L,EAAOvN,IAEFmQ,EAAeC,GAAerN,EACnC0K,EAAOhM,EACPgM,EAAOzN,GAEHqQ,EAAetN,EACnBwK,EAAO9L,EACP8L,EAAOxM,GAEHuP,EAAiBvN,EACrB0K,EAAOhM,EACPgM,EAAO1M,GAEH+K,EAAUjF,EAAuB,MAEvClE,GAA0B,KACxB,MAAMkC,EAAOiH,EAAQrF,GACfkF,EAAYtE,EAAQgE,EAAaxG,GACjC0L,EAAW/B,EAAU5J,EAAUC,GAC/B2L,EAAW/B,EAAU7J,EAAUC,GACrC,MAAO,KACL8G,IACA4E,IACAC,GAAU,CACX,GACA,IAEH7N,GAA0B,KACpB0N,EAAatT,QACfyR,EAAUjI,EAAe8J,EAAcJ,EACxC,GACA,CAACI,IACJ1N,GAA0B,KACpB2N,EAAevT,QACjB0R,EAAUlI,EAAe+J,EAAgBH,EAC1C,GACA,CAACG,IAEJ,MAAMG,EAAS3I,GAAQ,KACrB,MAAMtK,EAAQ,IAAI6R,IAClB,MAAO,CAACvC,EAAkBE,KACxB,IAAIzI,EAA2B/G,EAAM4N,IAAImB,EAAOO,EAAUE,IAO1D,OANKzI,GACH/G,EAAMkO,IACJa,EAAOO,EAAUE,GAChBzI,EAAI4C,EAAS,CAAE2F,WAAUE,cAGvBzI,CAAC,CACT,GACA,CAAC4C,IAEEuJ,EAA0BjU,EAAIwT,EAAgB3G,EAAU,GACxDqH,EAAwBpU,EAAI2T,EAAc5G,EAAUsE,EAAW,GAC/DgD,EAA0BnU,EAAI0T,EAAgB7G,EAAU,GACxDuH,EAAwBtU,EAAI6T,EAAc9G,EAAUwE,EAAW,GAC/DzB,EAAQvE,GAAQ,KACpB,MAAMwE,EAAsB,GAC5B,IAAK,IAAIlP,EAAIsT,EAAyBtT,GAAKuT,EAAuBvT,IAChE,IAAK,IAAIuH,EAAIiM,EAAyBjM,GAAKkM,EAAuBlM,IAChE2H,EAAIlK,KACFwF,EAAC4E,EAEC,CAAApF,EAAUC,EACVoF,GAAgBc,EAChBZ,GAAkBc,EAClBZ,GAAWzP,EACX2P,GAAWpI,EACX6C,EAAUmC,EACVzC,EAAWuJ,EAAOrT,EAAGuH,IAPhB4H,EAAOnP,EAAGuH,KAavB,OAAO2H,CAAG,GACT,CACDmE,EACAC,EACAC,EACAC,EACAC,IAGF,OACEjJ,EAACiB,EAAM,CACLE,EAAM+C,EACNwB,GAASC,EACTC,GAASC,EACTjG,EAAUkC,EACVV,EAAYoF,GAAqBE,EACjCpH,EAAWmF,EACXpD,EAAQgB,GACR"}